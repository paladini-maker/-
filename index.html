<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IPTV â€” Shaka + ClearKey + Chromecast (Corregido)</title>

<!-- 1) Google Cast sender: cargar primero -->
<script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1" async></script>

<script>
  // Inicializar CAST apenas la API estÃ© disponible
  window.__onGCastApiAvailable = function(isAvailable) {
    if (!isAvailable) {
      console.warn("Cast API no disponible");
      return;
    }
    try {
      const ctx = cast.framework.CastContext.getInstance();
      ctx.setOptions({
        // Default Media Receiver o reemplazÃ¡ por tu APP_ID custom si lo tenÃ©s
        receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
        // polÃ­tica robusta que evita sesiones fantasma entre pestaÃ±as
        autoJoinPolicy: chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED
      });
      console.log("Cast API inicializada correctamente");
    } catch (e) {
      console.error("Error inicializando Cast API:", e);
    }
  };
</script>

<!-- 2) Shaka Player (puede cargarse despuÃ©s de Cast) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/4.12.3/shaka-player.compiled.js"></script>

<style>
  :root{ --bg:#0b0b0b; --panel:#0f1113; --muted:#9aa0a6; --accent:#1db954; }
  body{ margin:0; font-family:Inter,system-ui,Arial; background:var(--bg); color:#fff; }
  header{ display:flex; align-items:center; gap:12px; padding:12px; background:#061016; }
  header h1{ margin:0; font-size:16px; }
  .wrap{ display:grid; grid-template-columns:320px 1fr; gap:12px; padding:12px; height:calc(100vh - 56px); box-sizing:border-box; }
  .sidebar{ background:var(--panel); border-radius:8px; padding:12px; overflow:auto; }
  .list { display:flex; flex-direction:column; gap:8px; }
  .channel { display:flex; gap:8px; align-items:center; background:#0b0d0f; padding:8px; border-radius:6px; }
  .channel img{ width:56px; height:36px; object-fit:contain; background:#000; border-radius:4px; }
  .chmeta{ flex:1; overflow:hidden; }
  .chname{ font-weight:600; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .chsub{ color:var(--muted); font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .btn { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; padding:6px 8px; border-radius:6px; cursor:pointer; }
  main{ display:flex; flex-direction:column; gap:10px; }
  #playerWrap{ background:#000; border-radius:8px; overflow:hidden; }
  video{ width:100%; height:56vh; background:#000; display:block; }
  .controls { display:flex; gap:8px; align-items:center; padding:8px; }
  #castGlobal { margin-left:auto; background:linear-gradient(90deg,#ffd54b,#ffb300); color:#000; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:700; }
  footer{ padding:6px 12px; color:var(--muted); font-size:12px; text-align:right; }
  @media(max-width:900px){ .wrap{ grid-template-columns:1fr; } video{ height:40vh; } }
</style>
</head>
<body>

<header>
  <h1>IPTV â€” Shaka + ClearKey + Chromecast (Corregido)</h1>
  <div style="margin-left:auto;color:var(--muted);font-size:13px;">HTTPS requerido (GitHub Pages)</div>
</header>

<div class="wrap">
  <aside class="sidebar">
    <div style="display:flex;gap:8px;margin-bottom:8px;">
      <input id="filter" placeholder="Buscar canal..." style="flex:1;padding:8px;border-radius:6px;border:0;background:#0b0d0f;color:#fff;outline:none" />
      <button id="refreshBtn" class="btn">Refrescar</button>
    </div>
    <div class="list" id="channelList"></div>
  </aside>

  <main>
    <div id="playerWrap"><video id="video" controls playsinline></video></div>
    <div class="controls">
      <div id="nowInfo">SeleccionÃ¡ un canal</div>
      <button id="playLocal" class="btn">â–¶ Reproducir local</button>
      <button id="castGlobal" title="Enviar al Chromecast">ðŸ“º Enviar al Chromecast</button>
    </div>
    <footer>Ãšltima carga: <span id="lastUpdate">â€”</span></footer>
  </main>
</div>

<script>
/* ===================== CONFIG ===================== */
/* ReemplazÃ¡ esta URL por la de tu repo / lista.m3u */
const M3U_URL = "https://raw.githubusercontent.com/paladini-maker/-/refs/heads/main/002.m3u";
/* ================================================= */

let channels = [], current = null, player = null;

/* ===== utils ===== */
function hexToBase64(hex) {
  if (!hex) return "";
  hex = hex.replace(/\s+/g,"").replace(/^0x/, "");
  if (hex.length % 2 !== 0) hex = "0" + hex;
  const bytes = hex.match(/.{1,2}/g).map(b => parseInt(b,16));
  let binary = "";
  for (let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}
function base64ToHex(b64) {
  if (!b64) return "";
  const bin = atob(b64);
  let hex = "";
  for (let i=0;i<bin.length;i++){ let h = bin.charCodeAt(i).toString(16); if (h.length===1) h="0"+h; hex+=h; }
  return hex;
}

/* ===== M3U parser (tu versiÃ³n robusta) ===== */
async function loadM3UAndParse(url) {
  channels = [];
  try {
    const res = await fetch(url, { cache: "no-cache" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = await res.text();
    document.getElementById("lastUpdate").textContent = new Date().toLocaleString();

    let lines = text.split(/\r?\n/);
    let pending = {};
    let globalKid = null, globalKey = null;

    for (let raw of lines) {
      const line = raw.trim();
      if (!line) continue;

      if (line.startsWith("#EXTM3U")) continue;

      if (line.startsWith("#KODIPROP:inputstream.adaptive.license_key=")) {
        const val = line.split("=",2)[1] || "";
        const s = val.trim().replace(/^"|"$/g,"");
        if (s.includes(":")) {
          const [gkid, gkey] = s.split(":");
          globalKid = gkid.toLowerCase();
          globalKey = gkey.toLowerCase();
        } else {
          try { const j = JSON.parse(s); if (j && j.keys && j.keys[0]) { globalKid = (j.keys[0].kid||"").toLowerCase(); globalKey = (j.keys[0].k||"").toLowerCase(); } } catch(e){}
        }
        continue;
      }

      if (line.startsWith("#KODIPROP:inputstream.adaptive.license_type")) continue;

      if (line.startsWith("#EXTINF")) {
        pending = { kid: globalKid, key: globalKey };
        const nameMatch = line.match(/,(.*)$/);
        pending.name = nameMatch ? nameMatch[1].trim() : "Canal";
        const idM = line.match(/tvg-id="(.*?)"/); pending.tvgId = idM ? idM[1] : null;
        const lgM = line.match(/tvg-logo="(.*?)"/); pending.logo = lgM ? lgM[1] : null;
        const gM = line.match(/group-title="(.*?)"/); pending.group = gM ? gM[1] : null;
        const nM = line.match(/ch-number="(.*?)"/); pending.chNumber = nM ? nM[1] : null;
        continue;
      }

      if (line.startsWith("#KODIPROP:inputstream.adaptive.license_key")) {
        const val = line.split("=",2)[1] || ""; const s = val.trim().replace(/^"|"$/g,"");
        if (s.includes(":")) { const [pkid,pkey] = s.split(":"); pending.kid = pkid.toLowerCase(); pending.key = pkey.toLowerCase(); }
        else { try { const j = JSON.parse(s); if (j && j.keys && j.keys[0]) { pending.kid = (j.keys[0].kid||"").toLowerCase(); pending.key = (j.keys[0].k||"").toLowerCase(); } } catch(e){} }
        continue;
      }

      if (line.startsWith("#EXTVLCOPT:dash-kid=")) { pending.kid = (line.split("=",2)[1] || "").trim().toLowerCase(); continue; }
      if (line.startsWith("#EXTVLCOPT:dash-key=")) { pending.key = (line.split("=",2)[1] || "").trim().toLowerCase(); continue; }

      if (!line.startsWith("#") && line.includes(".mpd")) {
        pending.mpd = line;
        if (!pending.kid && globalKid) pending.kid = globalKid;
        if (!pending.key && globalKey) pending.key = globalKey;
        channels.push({
          name: pending.name || pending.mpd,
          logo: pending.logo || "",
          group: pending.group || "",
          tvgId: pending.tvgId || "",
          chNumber: pending.chNumber || "",
          mpd: pending.mpd,
          kid: pending.kid ? pending.kid.toLowerCase() : null,
          key: pending.key ? pending.key.toLowerCase() : null
        });
        pending = {};
      }
    }
    renderChannelList();
  } catch (err) {
    console.error("Error cargando M3U:", err);
    alert("Error cargando M3U: " + err.message);
  }
}

/* ===== UI render ===== */
function renderChannelList() {
  const el = document.getElementById("channelList"); el.innerHTML = "";
  channels.forEach((ch, idx) => {
    const div = document.createElement("div"); div.className = "channel";
    div.innerHTML = `
      <img src="${ch.logo || 'https://via.placeholder.com/120x76?text=No+Logo'}" alt="">
      <div class="chmeta">
        <div class="chname">${ch.name}</div>
        <div class="chsub">${ch.group || ''} ${ch.chNumber ? 'â€¢ ' + ch.chNumber : ''} ${ch.tvgId ? 'â€¢ ' + ch.tvgId : ''}</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px;">
        <button class="btn" onclick="selectChannel(${idx})">Seleccionar</button>
        <button class="btn" onclick="castChannelByIndex(${idx})">ðŸ“º Cast</button>
      </div>
    `;
    el.appendChild(div);
  });
}

/* ===== Shaka init ===== */
async function initShaka() {
  shaka.polyfill.installAll();
  if (!shaka.Player.isBrowserSupported()) { alert("Navegador no soporta Shaka Player."); return; }
  player = new shaka.Player(document.getElementById("video"));
  player.addEventListener('error', e => console.error("Shaka error", e));
  console.log("Shaka listo");
}

/* ===== select + play local ===== */
function selectChannel(idx) {
  current = channels[idx];
  document.getElementById("nowInfo").textContent = `Seleccionado: ${current.name}`;
}
async function playLocal() {
  if (!current) { alert("SeleccionÃ¡ un canal primero."); return; }
  try {
    if (current.kid && current.key) {
      // Shaka acepta hex KID:KEY (segÃºn tu lista)
      await player.configure({ drm: { clearKeys: { [current.kid]: current.key } } });
    } else {
      await player.configure({ drm: {} });
    }
    await player.load(current.mpd);
    console.log("Reproduciendo local:", current.name);
  } catch (e) {
    console.error("Error reproducir local:", e);
    alert("Error reproducir local. Mira consola.");
  }
}

/* ===== CAST helpers - robust ClearKey payloads + retries ===== */
function castChannelByIndex(idx) { selectChannel(idx); castChannel(current); }

async function castChannel(ch) {
  if (!ch) { alert("No hay canal seleccionado"); return; }
  if (!window.cast || !cast.framework) {
    alert("Cast API no disponible en este navegador.");
    return;
  }

  const ctx = cast.framework.CastContext.getInstance();
  try {
    if (!ctx.getCurrentSession()) await ctx.requestSession();
  } catch (e) {
    console.error("Usuario cancelÃ³ picker o no hay sesiÃ³n:", e);
    return;
  }

  const session = ctx.getCurrentSession();
  if (!session) { alert("No hay sesiÃ³n Cast activa"); return; }

  // Preparar keys en formas hex y base64
  const keys = {};
  if (ch.kid && ch.key) {
    const kidHex = ch.kid.replace(/^0x/, "").toLowerCase();
    const keyHex = ch.key.replace(/^0x/, "").toLowerCase();
    const kidB64 = hexToBase64(kidHex);
    const keyB64 = hexToBase64(keyHex);
    // incluir ambas variantes (hex-keyed mapping y base64-keyed mapping)
    keys[kidHex] = keyHex;
    keys[kidB64] = keyB64;
  }

  // Construir mediaInfo
  const mediaInfo = new chrome.cast.media.MediaInfo(ch.mpd, "application/dash+xml");
  const metadata = new chrome.cast.media.GenericMediaMetadata();
  metadata.title = ch.name;
  if (ch.logo) metadata.images = [{ url: ch.logo }];
  mediaInfo.metadata = metadata;

  // Intentos: 1) drm.clearkeys + clearkeys (ambos), 2) solo clearkeys (hex), 3) solo drm.clearkeys (base64), 4) sin customData
  const payloads = [];

  if (Object.keys(keys).length) {
    payloads.push({
      desc: "drm + clearkeys (hex+base64)",
      customData: { clearkeys: keys, drm: { type: "clearkey", clearkeys: keys } }
    });
    // only hex mapping
    const onlyHex = {}; onlyHex[Object.keys(keys)[0]] = keys[Object.keys(keys)[0]];
    payloads.push({ desc: "only clearkeys (hex)", customData: { clearkeys: onlyHex } });
    // only base64 mapping
    const base64Map = {}; base64Map[Object.keys(keys).find(k=>k.indexOf('=')>=0)] = Object.values(keys).find(v=>v.indexOf('=')>=0);
    if (Object.keys(base64Map).length) payloads.push({ desc: "only clearkeys (base64)", customData: { clearkeys: base64Map } });
  }
  // final fallback (no customData)
  payloads.push({ desc: "no customData", customData: undefined });

  // Try sequentially until one works
  for (let i=0;i<payloads.length;i++) {
    const p = payloads[i];
    mediaInfo.customData = p.customData;
    const request = new chrome.cast.media.LoadRequest(mediaInfo);
    request.autoplay = true;
    request.currentTime = 0;

    try {
      console.log("Intentando cast â€” payload:", p.desc);
      await session.loadMedia(request);
      console.log("Carga al Chromecast OK con payload:", p.desc);
      return; // success
    } catch (err) {
      console.warn("Intento de cast fallÃ³ con payload:", p.desc, err);
      // si fue el Ãºltimo intento, mostrar error
      if (i === payloads.length - 1) {
        console.error("Todos los intentos de cast fallaron.");
        alert("Error: no se pudo castear el canal. RevisÃ¡ consola (CORS/compatibilidad/DMR).");
      } else {
        // wait brevemente y reintentar con siguiente payload
        await new Promise(r => setTimeout(r, 300));
      }
    }
  }
}

/* ===== UI wiring ===== */
document.getElementById("refreshBtn").addEventListener("click", () => loadM3UAndParse(M3U_URL));
document.getElementById("playLocal").addEventListener("click", playLocal);
document.getElementById("castGlobal").addEventListener("click", () => { if (!current) { alert("SeleccionÃ¡ un canal primero."); return; } castChannel(current); });
document.getElementById("filter").addEventListener("input", (e) => {
  const q = (e.target.value || "").toLowerCase();
  const filtered = channels.filter(c => (c.name && c.name.toLowerCase().includes(q)) || (c.group && c.group.toLowerCase().includes(q)) || (c.tvgId && c.tvgId.toLowerCase().includes(q)) || (c.chNumber && String(c.chNumber).includes(q)));
  const el = document.getElementById("channelList"); el.innerHTML = "";
  filtered.forEach((c) => {
    const idx = channels.indexOf(c);
    const div = document.createElement("div"); div.className = "channel";
    div.innerHTML = `
      <img src="${c.logo || 'https://via.placeholder.com/120x76?text=No+Logo'}" alt="">
      <div class="chmeta">
        <div class="chname">${c.name}</div>
        <div class="chsub">${c.group || ''} ${c.chNumber ? 'â€¢ ' + c.chNumber : ''}</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px;">
        <button class="btn" onclick="selectChannel(${idx})">Seleccionar</button>
        <button class="btn" onclick="castChannelByIndex(${idx})">ðŸ“º Cast</button>
      </div>`;
    el.appendChild(div);
  });
});

/* ===== inicio ===== */
document.addEventListener("DOMContentLoaded", async () => { await initShaka(); await loadM3UAndParse(M3U_URL); });
</script>

</body>
</html>
