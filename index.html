<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Canales + Shaka + Chromecast</title>
  <!-- Shaka Player con UI -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/4.0.0/shaka-player.ui.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/4.0.0/controls.min.css"/>
  <!-- Google Cast Sender SDK -->
  <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>

  <style>
    body { font-family: sans-serif; margin: 20px; }
    #channels { margin-bottom: 20px; }
    #channels button { display: block; margin: 4px 0; padding: 8px; }
    #videoContainer { max-width: 640px; margin: auto; }
  </style>
</head>
<body>
  <h1>Selecciona un canal</h1>
  <div id="channels">Cargando canales…</div>

  <div id="videoContainer"
       data-shaka-player-container
       data-shaka-player-cast-receiver-id="CC1AD845">
    <video id="video" width="640" controls autoplay data-shaka-player></video>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', initApp);

    async function initApp(){
      shaka.polyfill.installAll();
      if (!shaka.Player.isBrowserSupported()) {
        console.error('Browser no soportado');
        return;
      }

      const video = document.getElementById('video');
      const ui = video.ui;  // la UI Library inicializa automáticamente
      const controls = ui.getControls();
      const player = controls.getPlayer();

      player.addEventListener('error', onErrorEvent);
      controls.addEventListener('error', onErrorEvent);

      // Cargar lista .m3u con metadatos KODIPROP
      try {
        const resp = await fetch('https://raw.githubusercontent.com/paladini-maker/-/refs/heads/main/002.m3u');
        const text = await resp.text();
        const channels = parseM3UWithKodiprop(text);
        buildChannelList(channels, player);
      } catch(e) {
        console.error('Error cargando lista de canales', e);
        document.getElementById('channels').textContent = 'No se pudo cargar la lista de canales.';
      }
    }

    function parseM3UWithKodiprop(text) {
      const lines = text.split('\n');
      const entries = [];
      let curr = null;

      for (let raw of lines) {
        const line = raw.trim();
        if (!line) continue;

        if (line.startsWith('#EXTINF:')) {
          const parts = line.split(',');
          curr = {
            title: (parts[1] || 'Sin título').trim(),
            url: null,
            kodiprops: {}
          };
        } else if (line.startsWith('#KODIPROP:') && curr) {
          const kv = line.substring('#KODIPROP:'.length).trim();
          const eq = kv.indexOf('=');
          if (eq >= 0) {
            const key = kv.substring(0, eq).trim();
            const value = kv.substring(eq+1).trim();
            curr.kodiprops[key] = value;
          }
        } else if (!line.startsWith('#') && curr) {
          curr.url = line;
          entries.push(curr);
          curr = null;
        }
      }
      return entries;
    }

    function buildChannelList(channels, player) {
      const div = document.getElementById('channels');
      div.innerHTML = '';
      channels.forEach(ch => {
        const btn = document.createElement('button');
        btn.textContent = ch.title;
        btn.onclick = () => {
          console.log('Seleccionado canal:', ch.title, ch.url, ch.kodiprops);
          configureAndLoad(player, ch);
        };
        div.appendChild(btn);
      });
    }

    async function configureAndLoad(player, channel) {
      // Reset config a base
      player.configure({
        drm: {
          clearKeys: {},
          servers: {}
        }
      });

      // Si hay kodiprops que indiquen ClearKey
      if (channel.kodiprops['inputstream.adaptive.license_type'] === 'clearkey' ||
          channel.kodiprops['license_type'] === 'clearkey') {
        // Se espera que kodiprops tenga key_id y key en hex o base64
        const kid = channel.kodiprops['key_id'] || channel.kodiprops['inputstream.adaptive.key_id'];
        const key = channel.kodiprops['key'] || channel.kodiprops['inputstream.adaptive.key'];
        if (kid && key) {
          // se asume hex; si son base64 necesitarás convertir
          const map = {};
          map[kid] = key;
          player.configure({ drm: { clearKeys: map } });
          console.log('Configurado ClearKey para canal', channel.title, map);
        } else {
          console.warn('Canal tiene clearkey declarado pero no todos los campos key_id / key están definidos');
        }
      } else if (channel.kodiprops['license_key']) {
        // Alternativa: url de licencia
        const licenseUrl = channel.kodiprops['license_key'];
        player.configure({ drm: { servers: { 'org.w3.clearkey': licenseUrl } } });
        console.log('Configurado servidor ClearKey para canal', channel.title, licenseUrl);
      } else {
        console.log('Sin DRM especial para canal', channel.title);
      }

      try {
        await player.load(channel.url);
        console.log('Canal cargado:', channel.title);
      } catch(e) {
        console.error('Error al cargar canal', channel.title, e);
      }
    }

    function onErrorEvent(event) {
      const error = event.detail || event;
      console.error('Shaka error código', error.code, 'objeto', error);
    }
  </script>
</body>
</html>
